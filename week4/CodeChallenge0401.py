# Randomized Motif Search

k = int(input("Enter k: "))
t = int(input("Enter t: "))
Dna = ["TCTCCACTATAAGTGGACAGCACCGGGTGCGGGAGAATTATAAATAGCACGCGCCGTTTGGTTACACCATAAATACGAGCAAATGGATAGTATCGCAATTCACAGGAAATAGATCTACAACCAACTCAACACCAGTGGTAGTGGCCGGATGAAGTCCCGCTGCGACTCAAGGTCTCCACTATAAGTG",
"GACAGCACCGGGTGCGGGAGAATTATAAATAGCACGCGCCGTTTGGTTACACCATAAATACGAGCAGCACCCATATTCTGAAATGGATAGTATCGCAATTCACAGGAAATAGATCTACAACCAACTCAACACCAGTGGTAGTGGCCGGATGAAGTCCCGCTGCGACTCAAGGTCTCCACTATAAGTG",
"AAGGGCTATGATGTCCGGCGCATTTGCCGCCAGTTGTTTCCTCGCTTAAAGCGGTGTTCGCCGGAGATACCCCGGCAGGAATATTCAAGCCGTCAGGTCCACTCTCGGCCTGCTCGATACGTTCCACACAATATTCCTCTCGTAGCCCCAATGCCTAATGCACTGGCCTGTACCTCATCGGTCTAGG",
"AGATTATAAGTTATACCTCTGGTTTATTCCCGGGTCTAGCAGACAGAAGGTGGGTGTGAAAATTTAGAGGTTACGTGCCAGGAATATTCTCGTCGTAGGCAGTCGAAATATTGGGATTTGAACATGAGGCCTAGAGATCAGAATCTCGAGCGGAAACGATAATTTAAACCTAACCAGAACTTAGGGA",
"AGTCATACTAAGAAACATACAGCTGAGCATCAGACACGGCAGGATGGTTCTGAGGCGCCGGTAAGCACGCGTTGACACACTGGGCGTCTCTGGCTACGGCAGCAACTTCAGCGCTCATCCTCAAATTGATCCATCGTTCAGTCTAAGTAGATGAGCTCCGTGGGTCACGTCTGATTAGTTGTCGACT",
"ATAGTCCTGCTCTGGGGTATTTCTGTTCCGTTCAGGGTTATATAAATAGGGACCGATCTGCTCTTACCAGTAAGTGGAAAATACCCGTCGTCGTAGGTGGCAGGAACGGTCTGATCGTGGTCAAAGTCACTTGCCGTTGTGCAGAAGAAAGAATAGGCTTAGGTAGTTCGATACAGCGCTAATGTAT",
"CACCTATGAGAAGTTAGCCACCGATCCACGACATGGGAAGCCATCAAGTTATCCGTGTGAATACGACGCTTGCAGACTTATTCTGATCGCTATTTGTTGAAACTGTTCAACAGTTACGCTGAGCCATGGATGGTTGATTATACAGGTTCACTATATTCAGCTCGCGGTTGAGCGCTTAGAATTAGGA",
"GACCGCCTCATGCTTGTTGAGACCACTTCGGGTACCGTGGAGATCTAATGATCACCCCCGCGGCGTAGCAGGTTCATTCTGAAAATCTGGGCCCCGGTCGGATGAGGGGCACTTCCGCAGTGTACAAACTGGGGGTGCGACTAAGGTCGGCGTAAGGGGGGCGCCTTGGTTAAGGTTTCTGGATGAA",
"CCACGCCTATCTTTACTGCGGTTTTTCTGGCAGAGCAAAAGCAATCTTTTTCGTACGTCCAGTGGGTTCACTCTAGGAATATTCTGCATTTGTCGGTCTCGGATGGGACGTATCGTTAATGAATAACTTCGGATGGGAACCAGCCCATTCACACGTGGAGTCAGACAGACTATTATCTGCGTACAAT",
"TGATTTGTTTAACGGTGCACTCCCGGCGTTTACTGAACCGTTGGAAGGTCGTACACAGACTCTGTACCTCACAACGCTAAGAGGACAAAGCCCGCAGGAATAACGTGAGTTCGGCTTTCAAGACCCGCATTTTTGAAATTTTGGTTGATAGCCCATATGTTGCTACGGTCTACCGTTTCGATGGGAC",
"GCCACAGCCTCAGTAATTATGCGCTTCGGGAATGTAACTGTGTGCGGTGATAAAAAACTTGGACTGCTACAGCTTCTATGAAAAATAGTATTACCACAGCAGTGCTTTAATATTCTGATGTTCTGGCAAGACTAAGGCTCGTTCTATTCTGTTCCAAATCGCGCACAGCAAAGTAAGATAATTTTCG",
"AAGGCATCGGGGAACGGCTCCTTCATACCCTAGGGATTACATCGGTCCGAATCCCGTTACACAAAGAGGGGAACCGTACGCATCCATATTCTGAGCCGCTAGATCCCCGTTCATCGATGAGCGTGCACCAAAATCTATCTAGCCAGTTCGTTCCTACAACAAACCGTGAGTCTGGGGATAGCAACAT",
"GGCCTGTGAATTGTACGGTCCGGTCGCTGCAGGAATCGCCTGATCCCGTAAGGGATTGAAATTAGAGACAGTTCTACTGGGTAAAACTGCACTGATAGTGAAATAAGGTAAAGGAATCCACACGGAGCGACAAAACCGGCAATTGATTGAGTGTCGCAACTTGGTGGCTTTGTAGTCCCGACCAGAC",
"CATAGAAACGCATGTATCGAGTTGATTGTTGCTTCGCAGTGGACGGCGGGAAACGGAACAGAGCGCGGCTCACACTCTCCATGTTGTCTCCGCGTCAGTCAACGCGACCCTGTACGTGTCCGTGACGCTCAGTTTTGAAAGACAATTTATCATCGACAACAGGGTTTGCAGGAATATTACAAGCTAT",
"GAGGAATATAGTGGTGCTAGAGGGTAAGAGTCCAGCCGTGACATTGTGCTAGATAATTGGGTCTTGGGTAACAGATTGTATACCAGAAGGATATGCAGGCGCATTCTGAAACCACTGTCAGAGTACAAGCGATCACGCACTTTAGGATATTCGGTAGACATCGGTAGTTCATGGCGCCCTAAAAATG",
"GTTGCTTAAAAGGAGAATTAGCACTGCCCTTACGTCTGGGGTATCACCTCCAGGTAGGTTTTGGCCCACGGGATTTGCCTAACTTTGTATAGGTTGCTTTAGGTCCGCCAGTACAAGAAACCTAGCTCTTGGTACTTTAACTAAGGAAAACTAAGGCGTTAGAATATTCTGAGGGGATGGAGCACGC",
"TGTTTCCCCATCCGGTAAGTTAGAGACACGCTGAACCGCCCCTCGGGTCCCGAGTAATCAGTGCAAATTTGGGCTCGTTACATATCGGGCCCGGATGGGGTAAATGCACCCCATCGACAGTAGGTAAATACTTCGTCACGACCGCGCAAGTCCCACGGCAGGCAAATATAGCAGAGGTATTCTGAGA",
"GTTCCGTGCAACAGCAAGATAGCAGCGTCGCTCAATGTCACTAGGCGTAACCTCGCACACAAATGGTTTAATAGCTTCAAATGCGGCCCAAACTACTTCCTACCAGAAACCCCAGCCAAGCGATGACTCATCTCAAGCACACCGATTCCGGATAGTTCCATGGAATATTCTGATAAGTGGTTGCTAC",
"GATCAGGGAAGATGTCAAGCAGTCTTTGCTGGTCCTCCCTGTGGTAGCCTCATATAACATTCCGCCAAGCCGTTGGGACTTGCGCGAGCCAGTGCGGGCGAGTGCGTCCAGGCAGCCTACTGGCGGGACAACTGTTATTAACGGAACCCTCTTCCGTGACTGACGATTATTGCAGGATGGTTCTGAG",
"GGCAGTGAGTTAGCATAATGGGAAATATGCGATTGCCAGGTACAAACCAGACAACTGGCAGGAATATCACGAGCGGATTTTTCCGTAGGAATCAGTCCCCCTTCCGGTGTTCATTAACACTTCGTTTAGTTATCACAGATTGTGCGGCCTGCGGGCGCTCGCCGGATATGCGTTTAGCGGAGGGTTA"]

def PseudoCount(Motifs):
    # returns a dictionary "count"
    count = {}
    k = len(Motifs[0])
    for symbol in "ACGT":
        count[symbol] = []
        for j in range(k):
            count[symbol].append(1)
    t = len(Motifs)
    for i in range(t):
        for j in range(k):
            symbol = Motifs[i][j]
            count[symbol][j] += 1
    return count


def PseudoProfile(Motifs):
    # returns a dictionary "profile"
    t = len(Motifs)
    k = len(Motifs[0])
    profile = {}
    profile = PseudoCount(Motifs)
    for symbol in 'ACGT':
        for j in range(k):
            profile[symbol][j] = profile[symbol][j] / float(t+4)
    return profile


def PseudoConsensus(Motifs):
    k = len(Motifs[0])
    counts = PseudoCount(Motifs)
    consensus = ""
    for j in range(k):
        m = 0
        frequentSymbol = ""
        for symbol in "ACGT":
            if counts[symbol][j] > m:
                m = counts[symbol][j]
                frequentSymbol = symbol
        consensus += frequentSymbol
    return consensus


def PseudoScore(Motifs):
    profile = PseudoCount(Motifs)
    Consensus = PseudoConsensus(Motifs)
    t = len(Motifs)
    score = 0
    for i in range(len(Motifs[0])):
        score = score + (t - profile[Consensus[i]][i])
    return score


def pr(Text, Profile):
    pr = 1
    for i in range(len(Text)):
        pr = pr * Profile[Text[i]][i]
    return pr


def profile_most_probable_pattern(Text, Profile):
    T = len(Text)
    K = len(Profile['A'])
    prob = 0
    x = Text[0:K]
    for i in range(T - K + 1):
        Subtext = Text[i:i + K]
        temp_prob = pr(Subtext, Profile)
        if temp_prob > prob:
            prob = temp_prob
            x = Subtext
    return x


def Pseudo_greedy_motif_search(Dna, k, t):
    BestMotifs = []
    for i in range(0, t):
        BestMotifs.append(Dna[i][0:k])
    n = len(Dna[0])
    for i in range(n - k + 1):
        Motifs = []
        Motifs.append(Dna[0][i:i + k])
        for j in range(1, t):
            P = PseudoProfile(Motifs[0:j])
            Motifs.append(profile_most_probable_pattern(Dna[j], P))
        if PseudoScore(Motifs) < PseudoScore(BestMotifs):
            BestMotifs = Motifs
    return BestMotifs


def Motifs(Profile, Dna):
    Motifs_list = []
    k = len(Profile)
    for Text in Dna:
        Motifs_list.append(profile_most_probable_pattern(Text, Profile))
    return Motifs_list

import random

def OneRandomizedMotifSearch(Dna, k, t):
    l = len(Dna[0])
    m = [random.randint(0, l-k) for _ in range(t)]
    motifs = [Dna[i][m[i]:m[i]+k] for i in range(t)]
    BestMotifs = motifs
    BestScore = PseudoScore(BestMotifs) # score of bestmotifs
    while True:
        Profile = PseudoProfile(motifs)
        motifs = Motifs(Profile, Dna)
        currScore = PseudoScore(motifs)
        if currScore < BestScore:
            BestMotifs = motifs
            BestScore = currScore
        else:
            return BestMotifs, BestScore

def RandomizedMotifSearch(Dna, k, t):
    iter = 1000
    BestScore = float('inf')
    for _ in range(iter):
        currBestMotifs, currBestScore = OneRandomizedMotifSearch(Dna, k, t)
        if currBestScore < BestScore:
            BestMotifs, BestScore = (currBestMotifs, currBestScore)
    return BestMotifs



dnayy = [
"ATGAGGTC",

"GCCCTAGA",

"AAATAGAT",

"TTGTGCTA"
]

motifyy = [
"GTC",

"CCC",

"ATA",

"GCT"
]
for foos in RandomizedMotifSearch(Dna, k, t):
    print(foos)

print(Motifs(PseudoProfile(motifyy), dnayy))
#print(Motifs(Profile, Dna))
